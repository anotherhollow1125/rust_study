---
marp: true
theme: rustlings
footer: "Rustå‹‰å¼·ä¼š2ndã€ç¬¬7å›ã€‘æ‰€æœ‰æ¨©(2)ãƒ»æ§‹é€ ä½“"
paginate: true
---
<!--
_footer: ""
_paginate: skip
-->

<div class="topbottom-align">
<div class="slide-title">
    <h1>Rustå‹‰å¼·ä¼š2nd</h1>
</div>

<div class="slide-info">
    <div>ã€œã€ç¬¬7å›ã€‘æ‰€æœ‰æ¨©(2)ãƒ»æ§‹é€ ä½“ ã€œ</div>
</div>
</div>

---

# ã€ç¬¬7å›ã€‘ç›®æ¬¡

1. æ‰€æœ‰æ¨©
   1. (å‰å›ã‚¹ãƒ©ã‚¤ãƒ‰å†æ²)
   2. move_semantics(1|2|3).rs â† æœ¬æ—¥ã“ã“ã‹ã‚‰
   3. ä¸å¤‰å‚ç…§ãƒ»å¯å¤‰å‚ç…§ã®èª¬æ˜
   4. move_semantics4.rs, move_semantics5.rs
2. æ§‹é€ ä½“
   1. èª¬æ˜
   2. structs1.rs, structs2.rs, structs3.rs

---

# æœ¬æ—¥ã®RustãƒŸãƒ‹ã‚¯ã‚¤ã‚º!

<div class="mini-font-marker-8"></div>

```rust
macro_rules! check_impl_copy {
    ($v:expr) => {
        let v1 = $v;
        let v2 = v1;
        println!("{v1:?}, {v2:?}");
    };
}

fn main() {
    /* 1. */ check_impl_copy!(10);
    /* 2. */ check_impl_copy!('\u{3042}');
    /* 3. */ check_impl_copy!(vec![1, 2, 3]);
    /* 4. */ check_impl_copy!([1, 2, 3]);
}
```

 1. ~ 4. ã®ã†ã¡ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã¨ãªã‚‹è¡Œã¯ã©ã‚Œã§ã—ã‚‡ã†ï¼Ÿ

---

# æœ¬æ—¥ã®RustãƒŸãƒ‹ã‚¯ã‚¤ã‚º! è£œè¶³

<div class="mini-font-marker-8"></div>

```rust
macro_rules! check_impl_copy {
    ($v:expr) => {
        let v1 = $v;
        let v2 = v1;
        println!("{v1:?}, {v2:?}");
    };
}
```

è£œè¶³: `check_impl_copy!(true)` ã¯ä»¥ä¸‹ã«å±•é–‹ã•ã‚Œã¾ã™

```rust
let v1 = true;
let v2 = v1;
println!("{v1:?}, {v2:?}");
```

---
<!--
footer: "Rustå‹‰å¼·ä¼š2ndã€ç¬¬6å›ã€‘(1. æ‰€æœ‰æ¨©)"
-->

<div class="group-title">
    <h1>1. æ‰€æœ‰æ¨©</h1>
</div>

---

# (å†æ²) æœ€åˆã®é›£é–¢: æ‰€æœ‰æ¨©

* ä»Šå›ã°ã‹ã‚Šã¯ [The Book](https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html) ã‚’èª­ã‚“ã§...ã¨ã„ã†æ„Ÿã˜ã§ã™ãŒã€
ã‚³ã‚¢ã‚¤ãƒ¡ãƒ¼ã‚¸ã ã‘é ‘å¼µã£ã¦è¨€èªåŒ–ã—ã¦ã¿ã¾ã™

* æ‰€æœ‰æ¨©ã¯ **ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ã‚ãšã«**
ãƒ¡ãƒ¢ãƒªå®‰å…¨ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã® **çˆ†å¼¾ã‚²ãƒ¼ãƒ ** ğŸ’£

---

# (å†æ²) æ‰€æœ‰æ¨©ã¯çˆ†å¼¾ã‚²ãƒ¼ãƒ  ğŸ’£ ï¼Ÿ

ãƒ«ãƒ¼ãƒ«

1. å‚åŠ è€…ã¯å¤‰æ•°
2. `Vec<T>`ãªã©ã€ã‚ã‚‹å€¤ãŒ**ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã§ã¯ãªã„æ™‚**
(`Copy` ã‚’å®Ÿè£…ã—ãªã„æ™‚)ã€"å€¤"ã‚’çˆ†å¼¾ã¨ã¿ãªã™
3. **å€¤ã¨ã—ã¦è©•ä¾¡ã•ã‚ŒãŸã‚‰** çˆ†å¼¾ã‚’æ‰‹æ”¾ã›ã‚‹
4. **çˆ†å¼¾ã‚’æŒã£ã¦ã„ã‚‹æ™‚ã ã‘** çˆ†å¼¾ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ (æ‰€æœ‰æ¨©)

---

```rust
fn main() {
    // vec![...]ãŒçˆ†å¼¾
    let v = vec![1, 2, 3]; // v ã¯çˆ†å¼¾ã‚’æŒã¤
    println!("{:?}", v); // vã‚’çµŒç”±ã—ã¦çˆ†å¼¾ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½

    let v2 = v; // å³è¾ºã§è©•ä¾¡ã•ã‚Œã‚‹ã®ã§ã€çˆ†å¼¾ã‚’æ‰‹æ”¾ã™

    println!("{:?}", v); // çˆ†å¼¾ã¯ã‚‚ã†æŒã£ã¦ãªã„ã®ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ï¼

    println!("{:?}", v2); // v2 ã¯çˆ†å¼¾ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹
}
```

---

ãƒ«ãƒ¼ãƒ«ç¶šã

* 1. å‚åŠ è€…ã¯å¤‰æ•°
2.ã‚ã‚‹å€¤ãŒ**ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã§ã¯ãªã„æ™‚** "å€¤"ã‚’çˆ†å¼¾ã¨ã¿ãªã™
3.**å€¤ã¨ã—ã¦è©•ä¾¡ã•ã‚ŒãŸã‚‰**çˆ†å¼¾ã‚’æ‰‹æ”¾ã›ã‚‹
4.**çˆ†å¼¾ã‚’æŒã£ã¦ã„ã‚‹æ™‚ã ã‘** çˆ†å¼¾ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ (æ‰€æœ‰æ¨©)

* 5. è‡ªåˆ†ã®ã‚¹ã‚³ãƒ¼ãƒ—çµ‚ç«¯ã¾ã§æ¥ãŸã‚‰çˆ†ç™ºğŸ’¥
**ãƒ¡ãƒ¢ãƒªä¸Šã‹ã‚‰ç‰‡ä»˜ã‘ã‚‹ç¾©å‹™**ãŒç”Ÿã˜ã€çˆ†å¼¾ã¯æ¶ˆæ»… (æ‰€æœ‰æ¨©ã‚‚æ¶ˆãˆã‚‹)

èª°ã‹ãŒãƒ¡ãƒ¢ãƒªã‚’ç‰‡ä»˜ã‘ãªã„ã¨ã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã«ãªã£ã¦ã—ã¾ã†

---

```rust
let v_res = {
    let v = vec![1, 2, 3]; // v ã¯çˆ†å¼¾ã‚’æŒã¤
    println!("{:?}", v); // vã‚’çµŒç”±ã—ã¦çˆ†å¼¾ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½

    let v2 = v.clone(); // çˆ†å¼¾ã®è¤‡è£½ï¼

    v2 // v2 ã¯è©•ä¾¡ã•ã‚Œã‚‹ã®ã§ã€ã‚®ãƒªã‚®ãƒªçˆ†å¼¾ã‚’å¤–ã«æ¨ã¦ã‚ŒãŸ
}; // v ã¯çˆ†å¼¾ãŒçˆ†ç™ºï¼ãƒ¡ãƒ¢ãƒªã‚’ç‰‡ä»˜ã‘ã‚‹

// ä»£ã‚ã‚Šã« v_res ãŒçˆ†å¼¾ã‚’ç‰‡ä»˜ã‘ã‚‹
```

---

# (å†æ²) èƒŒæ™¯: Cè¨€èªã® `free` é–¢æ•°

GCãŒãªã„Cè¨€èªã¯ã€ãƒ’ãƒ¼ãƒ—ã«ç¢ºä¿ã—ãŸå‹•çš„é…åˆ—ã¯
è‡ªåˆ†ã§ `free` ã—ãªã„ã¨ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã«ãªã‚Šã¾ã™ã€‚

```c
#include <stdlib.h>

int main(void) {
    int* v = (int*)malloc(10); // ãƒ’ãƒ¼ãƒ—ã«ãƒ¡ãƒ¢ãƒªç¢ºä¿

    // ...

    free(v); // ã“ã‚ŒãŒãªã„ã¨ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ï¼
} 
```

---

å¸¸é§ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’è¨±å®¹ã—ãŸãã‚ã‚Šã¾ã›ã‚“

ä¸€æ–¹ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒ `free` é–¢æ•°ã‚’è‡ªåˆ†ã§å‘¼ã¶ã“ã¨ã§ã€
ã€ŒäºŒé‡freeãƒã‚°ã€ãªã©ã®æ•°ã€…ã®å‡¶æ‚ªãªãƒã‚°ãŒç”Ÿã¾ã‚Œã¦ãã¾ã—ãŸ...

åŸºæœ¬çš„ã« **ã€Œã‚¹ã‚³ãƒ¼ãƒ—çµ‚ç«¯ã§ `free` ã™ã‚‹ã€**
ã¨ãƒ«ãƒ¼ãƒ«ã‚’æ±ºã‚ãŸã®ãŒRustã€ã¨ã„ã†ã‚ã‘ã§ã™ï¼

---

# move_semantics(1|2|3).rs å•é¡Œ 1/2

move_semantics1.rs ~ move_semantics3.rs
ã¯ç°¡å˜ã‹ã¤é¡ä¼¼ã—ãŸå•é¡Œã®ãŸã‚ã¾ã¨ã‚ã¦è¡Œã„ã¾ã™

```rust
// TODO: æ–°ã—ã„è¡Œã‚’åŠ ãˆã‚‹ã“ã¨ãªãã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„
fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    // let mut vec = vec; // <- ã“ã‚Œã®ä½¿ç”¨ç¦æ­¢ï¼

    vec.push(88);

    vec
}
```

---

# move_semantics(1|2|3).rs å•é¡Œ 2/2

ã“ã¡ã‚‰ãŒæœ¬å‘½ã®å•é¡Œã§ã™ã€‚

```rust
// TODO: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’ç›´ã™ãŸã‚ã€vec0ã¨vec1ã«**åŒæ™‚ã«**ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„
#[test]
fn move_semantics2() {
    let vec0 = vec![22, 44, 66];

    let vec1 = fill_vec(vec0);

    assert_eq!(vec0, [22, 44, 66]);
    assert_eq!(vec1, [22, 44, 66, 88]);
}
```

---

# å›°ã£ãŸã‚‰ `clone` ã§è§£æ±ºï¼

`#[derive(Clone)]` ã¨ã—ã¦ `Clone` ãƒˆãƒ¬ã‚¤ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å‹ãªã‚‰ã°ã€
`.clone()` ã§è¤‡è£½ãŒå¯èƒ½

```rust
#[derive(Clone)]
// â†‘ ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã—ã‹å«ã¾ãªã„æ™‚ã¯ #[derive(Clone, Copy)] ãªã‚“ã‹ã«ã‚‚
struct Human(String);

fn main() {
    let h = Human("".to_string());
    
    let _ = h.clone();
}
```

---

ã¡ãªã¿ã« `derive` ã‚’ä½¿ã‚ãšæ‰‹å‹•å®Ÿè£…ã‚‚ã§ãã¾ã™ã€‚

```rust
impl Clone for Human {
    fn clone(&self) -> Self {
        Self {
            name: self.0.clone()
        }
    }
}
```

---

```rust
fn main() {
    let v = vec![3, 1, 4, 1, 5, 9, 2];
    
    // for n in v { // <- vã®æ‰€æœ‰æ¨©ãŒå¥ªã‚ã‚Œã¦ã—ã¾ã†
    for n in v.clone() { // è¤‡è£½ã—ã¦ã—ã¾ãˆã°ã„ã„
        println!("{n}");
    }

    v.into_iter()
        .for_each(|n| println!("{n}"));
}
```

æ‰€æœ‰æ¨©ãŒå¥ªã‚ã‚Œã¦å›°ã‚‹æ™‚ã¯ `.clone()` ã—ã¦ã—ã¾ãˆã°9å‰²ã¯è§£æ±ºã—ã¾ã™ï¼

(å ´åˆã«ã‚ˆã£ã¦ã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒçŠ ç‰²ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‘ã©...)

---

# move_semantics(1|2|3).rs è§£ç­” 1/2

å¼•æ•°ã¯é–¢æ•°ã®å¼•æ•°å®£è¨€éƒ¨åˆ†ã§å¯å¤‰ã«ã§ãã¾ã™ã€‚

```rust
fn fill_vec(mut vec: Vec<i32>) -> Vec<i32> {
    vec.push(88);

    vec
}
```

---

# move_semantics(1|2|3).rs è§£ç­” 2/2

`.clone()` ã§è¤‡è£½ã™ã‚‹ã“ã¨ã§æ‰€æœ‰æ¨©å•é¡Œã‚’å›é¿ã—ã¾ã—ã‚‡ã†ï¼

```rust
#[test]
fn move_semantics2() {
    let vec0 = vec![22, 44, 66];

    let vec1 = fill_vec(vec0.clone());

    assert_eq!(vec0, [22, 44, 66]);
    assert_eq!(vec1, [22, 44, 66, 88]);
}
```

---

# æ‰€æœ‰æ¨©ã®ã›ã„ã§...

æ‰€æœ‰æ¨©ã¯å¤‰æ•°ã«å¯¾ã™ã‚‹è­²æ¸¡ã ã‘ã§ã¯ãªãã€
**é–¢æ•°ã®å¼•æ•°ã«æ¸¡ã™éš›ã‚‚ç™ºç”Ÿ** (è©•ä¾¡ã•ã‚Œã‚‹éš›ã«è¡Œã‚ã‚Œã‚‹ã®ã§)

```rust
fn func(s: String) {
    println!("{s}");
}

fn main() {
    let t = "Some Value".to_string();

    func(t);
    func(t); // <- ã‚¨ãƒ©ãƒ¼ï¼
}
```

---

`clone` ã‚’ä½¿ã‚ãªã„è§£æ±ºç­–ã¨ã—ã¦ã¯ã€
å€¤ã‚’é–¢æ•°ã§è¿”å´ã™ã‚Œã°æ‰€æœ‰æ¨©ã‚’å…ƒã®ã‚¹ã‚³ãƒ¼ãƒ—ã«æˆ»ã›ã¾ã™

```rust
fn func(s: String) -> String {
    println!("{s}");
    s
}
fn main() {
    let t = "Some Value".to_string();

    let t = func(t); // <- ãƒªãƒã‚¤ãƒ³ãƒ‰
    let _ = func(t);
}
```

ã§ã‚‚ã€é¢å€’ã§ã™ã‚ˆã­...ï¼Ÿ

---

# ä¸å¤‰å‚ç…§ã¨å¯å¤‰å‚ç…§

ã€Œæ‰€æœ‰æ¨©ã‚’å¥ªã‚ãšã«ãƒªã‚½ãƒ¼ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ‰‹æ®µã€ãŒ **å‚ç…§** ã§ã™ï¼

å¤‰æ•° `let v: Type` ã«å¯¾ã—ã¦

- `&v` ã§ä¸å¤‰å‚ç…§ãŒ
- `&mut v` ã§å¯å¤‰å‚ç…§ãŒ

å¾—ã‚‰ã‚Œã¾ã™

`&v` ã®å‹åã¯ `&Type`ã€ `&mut v` ã®å‹åã¯ `&mut Type` ã«ãªã‚Šã¾ã™ï¼

---

å…ˆã®ã‚³ãƒ¼ãƒ‰ä¾‹ã® `func` ã¯å¼•æ•°ã‚’æ¨™æº–å‡ºåŠ›ã™ã‚‹ã®ã¿ãªã®ã§ã€
ä¸å¤‰å‚ç…§ãŒã‚ã‚Œã°ååˆ†ã§ã™ï¼

```rust
fn func(s: &str) { // &String ã§ã‚‚è‰¯ã„ãŒä½¿ãˆã‚‹ãªã‚‰ &str ãŒè‰¯ã„
    println!("{s}");
}
fn main() {
    let t = "Some Value".to_string();

    func(&t);
    func(&t);
}
```

---

# ä¸å¤‰å‚ç…§ãƒ»å¯å¤‰å‚ç…§ã®ä½¿ã„æ‰€

- ä¸å¤‰å‚ç…§ã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹
  - å¤‰æ•°ã®å‚ç…§ãƒ»å‡ºåŠ› (æ¨™æº–å‡ºåŠ›ãƒ»ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ãªã©)
  - **ãƒªã‚½ãƒ¼ã‚¹è¤‡è£½** ( ref: `Clone::clone(&self)` )
- å¯å¤‰å‚ç…§ã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹
  - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç­‰ã®å€¤ã®æ›¸ãæ›ãˆ
  - é…åˆ—ã®ã‚½ãƒ¼ãƒˆ
  - å†å¸°é–¢æ•°ã§å‰¯ä½œç”¨ã‚’èµ·ã“ã™æ™‚
  - (ä½¿ç”¨é »åº¦ã¯é«˜ããªã„)

---

# ä¸å¤‰å‚ç…§ãƒ»å¯å¤‰å‚ç…§ã®é‡è¦ãªãƒ«ãƒ¼ãƒ«

1. å‚ç…§ãŒã‚ã‚‹é–“ã¯ã€æœ¬ä½“ã¯(ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ã‚‚)**å€¤ã‚’å¤‰æ›´ã§ããªã„**
2. ä¸å¤‰å‚ç…§ã¯åŒæ™‚ã«è¤‡æ•°å­˜åœ¨å¯èƒ½
3. **å¯å¤‰å‚ç…§ã¯åŒæ™‚ã«ä¸€ã¤ã—ã‹å­˜åœ¨ã§ããªã„**
4. **å¯å¤‰å‚ç…§ã¨ä¸å¤‰å‚ç…§ã®å­˜åœ¨ã¯XOR**
5. å‚ç…§ã¯ **æœ¬ä½“ãŒç”Ÿãã¦ã„ã‚‹é–“ã—ã‹å­˜åœ¨ã§ããªã„**
   - ç”Ÿãã¦ã„ã‚‹é–“ = ã‚¹ã‚³ãƒ¼ãƒ—çµ‚ç«¯ã‚ˆã‚Šå‰ (ã“ã‚Œã‚’**ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ **ã¨ã„ã†)
   - å‚ç…§è‡ªä½“ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒå°½ãã¦ã‚‚æœ¬ä½“ã¯ç”Ÿãã¦ã‚‹

---

![w:1100](07-assets/ref_of_rust.png)

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«èµ°ã‚‹ **ãƒœãƒ­ãƒ¼ãƒã‚§ãƒƒã‚«ãƒ¼** ã«ã‚ˆã‚Šãƒ«ãƒ¼ãƒ«ãŒä¿éšœã•ã‚Œã‚‹

---

# å¯å¤‰å‚ç…§ã¯ãªãœä¸€ã¤ï¼Ÿ

å‚è€ƒè¨˜äº‹: [&mutãŒä¸€ã¤ã—ã‹ä½œã‚Œãªã„ã“ã¨ã«ç´å¾—ã§ããªã„Rustaceanã¸](https://qiita.com/msakuta/items/e8935cbb4d4fe90a47d1)

```rust
fn g(a: &Option<i32>, b: &mut Option<i32>) {
    if let Some(ref v) = a {
        *b = None;
        println!("{}", v);
    }
}
```

ã“ã®ã‚ˆã†ãªé–¢æ•°ã‚’è€ƒãˆã‚‹

---

```rust
fn g(a: &Option<i32>, b: &mut Option<i32>) {
    if let Some(ref v) = a {
        *b = None;
        println!("{}", v);
    }
}
fn main() {
    let mut c = Some(1);
    g(&c, &mut c);
}
```

`c` ãŒ `Some` ãªã®ã§ `c` ã®ä¸­èº«ãŒ `None` ã«å¤‰æ›´ã•ã‚Œã¾ã™ã€‚

`v` ã¯**ãƒ¡ãƒ¢ãƒªã‹ã‚‰æ¶ˆãˆãŸ `Some` ã®ä¸­èº«ã‚’å‚ç…§ã™ã‚‹** ã®ã§ã€æœªå®šç¾©å‹•ä½œï¼

---

# move_semantics4.rs å•é¡Œ

```rust
// TODO: è¡Œã®ä¸¦ã¹æ›¿ãˆã®ã¿ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’ç›´ã—ã¦ãã ã•ã„ï¼
// ä¸¦ã¹æ›¿ãˆä»¥å¤–(è¿½åŠ ãƒ»å‰Šé™¤ãƒ»ç·¨é›†)ã¯ç¦æ­¢ã§ã™ã€‚
#[test]
fn move_semantics4() {
    let mut x = Vec::new();
    let y = &mut x;
    let z = &mut x;
    y.push(42);
    z.push(13);
    assert_eq!(x, [42, 13]);
}
```

---

# move_semantics5.rs å•é¡Œ 1/2

```rust
// TODO: `&` ã‚’ä»˜ã‘åŠ ãˆãŸã‚Šæ¶ˆã—ãŸã‚Šã™ã‚‹ã®ã¿ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’è§£æ¶ˆã—ã¦ãã ã•ã„

// æ‰€æœ‰æ¨©ã‚’å–ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“
fn get_char(data: String) -> char {
    data.chars().last().unwrap()
}

// æ‰€æœ‰æ¨©ã‚’å–ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
fn string_uppercase(mut data: &String) {
    data = data.to_uppercase();

    println!("{data}");
}
```

---

# move_semantics5.rs å•é¡Œ 2/2

ã‚·ã‚°ãƒãƒãƒ£é€šã‚Šã«å‚ç…§ãŒå–ã‚‰ã‚Œã¦å‘¼ã³å‡ºã•ã‚Œã¦ã„ã¾ã™

(ä¿®æ­£ã®å¿…è¦ã‚ã‚Š)

```rust
fn main() {
    let data = "Rust is great!".to_string();

    get_char(data);

    string_uppercase(&data);
}
```

---

# TIPS: æ‰€æœ‰æ¨©ã®å­˜åœ¨æ„ç¾©

ã€Œæ‰€æœ‰æ¨©ãƒ»ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãªã‚“ã¦å®ˆã£ã¦ä½•ã®ãƒ¡ãƒªãƒƒãƒˆãŒã‚ã‚‹ã‚“ã ï¼Ÿã€
ã¨æ€ã£ãŸäººã¯æ¬¡ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’èª¿ã¹ã¦ã¿ã¦ãã ã•ã„

- ã‚·ãƒ£ãƒ­ãƒ¼ã‚³ãƒ”ãƒ¼
  - æ‰€æœ‰æ¨©ãƒ»ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®ãŠã‹ã’ã§ã€è€ƒãˆãªãã¦æ¸ˆã¿ã¾ã™
- RAII ã¨ `Drop` ãƒˆãƒ¬ã‚¤ãƒˆ
  - ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿå­˜æœŸé–“ãŒã‚ã‹ã‚Šã‚„ã™ã„ã®ã§ã€
  ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒã‚¤ãƒ³ã‚¿ç­‰ã®ä¸æ­£çŠ¶æ…‹ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã›ã‚“
  - ä»–è¨€èªã ã¨: `with` æ–‡ã€ `using` ãƒ–ãƒ­ãƒƒã‚¯ã€ `defer` æ–‡

---

# move_semantics4.rs è§£ç­”

ãƒ‰ãƒ­ãƒƒãƒ—å¯èƒ½ãªã‚‰ã°
ã‚¹ã‚³ãƒ¼ãƒ—çµ‚ç«¯ã§ãªãã¨ã‚‚ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã‚Œã‚‹ä»•æ§˜ã‚’åˆ©ç”¨

```rust
#[test]
fn move_semantics4() {
    let mut x = Vec::new();
    let y = &mut x;
    y.push(42); // ä¸¦ã³æ›¿ãˆãŸ // -> ã“ã“ã§ y ã¯ãƒ‰ãƒ­ãƒƒãƒ—
    let z = &mut x; // ä¸¦ã³æ›¿ãˆãŸ
    z.push(13);
    assert_eq!(x, [42, 13]);
}
```

---

# move_semantics5.rs è§£ç­”

<div class="mini-font-marker-7"></div>

```rust
fn get_char(data: &String) -> char { // & ã‚’åŠ ãˆãŸ
    data.chars().last().unwrap()
}
fn string_uppercase(mut data: String) { // & ã‚’å¤–ã—ãŸ
    data = data.to_uppercase();
    println!("{data}");
}
fn main() {
    let data = "Rust is great!".to_string();

    get_char(&data); // & ã‚’åŠ ãˆãŸ

    string_uppercase(data); // & ã‚’å¤–ã—ãŸ
}
```

[`chars` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://doc.rust-lang.org/std/string/struct.String.html#method.chars)ã‚’è¦‹ã‚‹ã¨ä¸å¤‰å‚ç…§ã®ã¿ã§ã‚ˆãã€
`string_uppercase` ã‚’è¦‹ã‚‹ã¨ `data` ã‚’ä¸Šæ›¸ãã™ã‚‹ãŸã‚ã«æ‰€æœ‰æ¨©ãŒå¿…è¦

---
<!--
footer: "Rustå‹‰å¼·ä¼š2ndã€ç¬¬7å›ã€‘(2. æ§‹é€ ä½“)"
-->

<div class="group-title">
    <h1>2. æ§‹é€ ä½“</h1>
</div>

---

# æ§‹é€ ä½“ 1/2

ã„ãã¤ã‹ã®å‹ã‚’ã¾ã¨ã‚ã¦æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚3ç¨®é¡ã‚ã‚Šã¾ã™ï¼

```rust
// é€šå¸¸ã®æ§‹é€ ä½“
struct Person {
    name: String,
    age: u8,
}

// ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“
struct IpV4(u8, u8, u8, u8);

// ãƒ¦ãƒ‹ãƒƒãƒˆæ§˜æ§‹é€ ä½“
struct SomeToken;
```

---

# æ§‹é€ ä½“ 2/2

ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã¯ `æ§‹é€ ä½“å { å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ }` ã®ã‚ˆã†ã«æ›¸ã„ã¦è¡Œã„ã¾ã™ã€‚
`new` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯ `æ§‹é€ ä½“æ ¼ç´å¤‰æ•°.ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å` ã®ã‚ˆã†ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚

```rust
let p = Person {
    name: "namnium".to_string(),
    age: 26
};

println!("Hello, My name is {}. I'm {} year old.", p.name, p.age);
```

---

# æ›´æ–°æ§‹æ–‡

æ—¢å­˜ã®æ§‹é€ ä½“å®Ÿä½“ãŒã‚ã‚‹æ™‚ã€ `..æ—¢å­˜ã®æ§‹é€ ä½“å®Ÿä½“` ã¨æ›¸ãã¨
å€¤ã‚’å¼•ãç¶™ã’ã¾ã™ï¼

```rust
let future_p = Person {
    age: p.age + 1,
    ..p // æŒ‡å®šã—ã¦ã„ãªã„ p.name ãŒå¼•ãç¶™ãŒã‚Œã‚‹
};
```

ãŸã ã—å…ƒã®æ§‹é€ ä½“ã®æ‰€æœ‰æ¨©ã¯å¤±ã‚ã‚Œã¾ã™(`clone` ç­‰ã™ã‚Œã°åˆ¥)

---

# é–¢é€£é–¢æ•°ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰

`impl` ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½¿ã†ã“ã¨ã§ã€
é–¢é€£é–¢æ•°ã‚ã‚‹ã„ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã§ãã¾ã™ï¼

<div class="mini-font-marker-8"></div>

```rust
impl Person {
    // é–¢é€£é–¢æ•°
    fn new(name: &str, age: u8) -> Self {
        Self {
            name: name.to_string(),
            age // age: age ã¨æ›¸ãå¿…è¦ã¯ãªã„
        }
    }
    // ãƒ¡ã‚½ãƒƒãƒ‰
    fn greet(&self) {
        println!("Hello, My name is {}. I'm {} year old.", self.name, self.age);
    }
}
```

---

```rust
impl Person {
    fn new(name: &str, age: u8) -> Self { .. }
    fn greet(&self) { .. }
}

fn main() {
    // é–¢é€£é–¢æ•°å‘¼ã³å‡ºã—
    let p = Person::new("namnium", 26);

    // ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—
    p.greet();
}
```

`Self` ã¯è‡ªåˆ†è‡ªèº«ã®å‹ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã€
`self` ã«ã¯ `p.method()` ã®ã‚ˆã†ã«å‘¼ã‚“ã æ™‚ã® `p` ãŒå…¥ã‚‹

---

# structs1.rs å•é¡Œ 1/3

è‰²ã‚’è¡¨ã™æ§‹é€ ä½“ã‚’å®šç¾©ã›ã‚ˆã¨ã„ã†å•é¡Œã§ã™ã€‚

```rust
struct ColorRegularStruct {
    // TODO: `regular_structs` ãƒ†ã‚¹ãƒˆã§æœŸå¾…ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ ã—ã¦ãã ã•ã„
    // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹ã¯ä½•ãŒè‰¯ã„ã§ã—ã‚‡ã†ã‹ï¼ŸRGBã®æœ€å°/æœ€å¤§å€¤ã¯ãªã‚“ã§ã—ã‚‡ã†ã‹ï¼Ÿ
}

struct ColorTupleStruct(/* TODO: `tuple_structs` ãƒ†ã‚¹ãƒˆã§æœŸå¾…ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ */);
```

ãƒ’ãƒ³ãƒˆ: é»’ã¯ `#000000` ã€ç™½ã¯ `#FFFFFF` ã§ã€
`FF` ã¯1ãƒã‚¤ãƒˆ(= 8bit)ã®æœ€å¤§å€¤255ã§ã™ã€‚

---

# structs1.rs å•é¡Œ 2/3

```rust
#[test]
fn regular_structs() {
    // TODO: (æ™®é€šã®)æ§‹é€ ä½“ã‚’å®Ÿä½“åŒ–ã—ã¦ãã ã•ã„
    // let green =

    assert_eq!(green.red, 0); assert_eq!(green.green, 255); assert_eq!(green.blue, 0);
}

#[test]
fn tuple_structs() {
    // TODO: ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“ã‚’å®Ÿä½“åŒ–ã—ã¦ãã ã•ã„
    // let green =

    assert_eq!(green.0, 0); assert_eq!(green.1, 255); assert_eq!(green.2, 0);
}
```

---

# structs1.rs å•é¡Œ 3/3

```rust
#[derive(Debug)]
struct UnitStruct;

#[test]
fn unit_structs() {
    // TODO: ãƒ¦ãƒ‹ãƒƒãƒˆæ§‹é€ ä½“ã‚’å®Ÿä½“åŒ–ã—ã¦ãã ã•ã„
    // let unit_struct =
    let message = format!("{unit_struct:?}s are fun!");

    assert_eq!(message, "UnitStructs are fun!");
}
```

---

# structs2.rs å•é¡Œ 1/2

<div class="mini-font-marker-7"></div>

```rust
#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}
fn create_order_template() -> Order {
    Order {
        name: String::from("Bob"),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}
```

---

# structs2.rs å•é¡Œ 2/2

```rust
#[test]
fn your_order() {
    let order_template = create_order_template();

    // TODO: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¨ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆæ§‹æ–‡ã‚’åˆ©ç”¨ã—ã¦ã‚ªãƒ¼ãƒ€ãƒ¼ã‚’ä½œæˆã—ã‚ˆã†ï¼
    // let your_order =

    assert_eq!(your_order.name, "Hacker in Rust");
    assert_eq!(your_order.year, order_template.year);
    assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
    assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
    assert_eq!(your_order.made_by_email, order_template.made_by_email);
    assert_eq!(your_order.item_number, order_template.item_number);
    assert_eq!(your_order.count, 1);
}
```

---

# structs3.rs å•é¡Œ 1/5

```rust
// æ§‹é€ ä½“ã¯ãƒ‡ãƒ¼ã‚¿ã ã‘ã§ãªããƒ­ã‚¸ãƒƒã‚¯ã‚’æŒã¤ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
// Package æ§‹é€ ä½“ã‚’å®šç¾©ã—ã€ãã®ãƒ­ã‚¸ãƒƒã‚¯ã«ã¤ã„ã¦ã‚‚ãƒ†ã‚¹ãƒˆã—ãŸã„ã§ã™
#[derive(Debug)]
struct Package {
    sender_country: String,
    recipient_country: String,
    weight_in_grams: u32,
}
impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: u32) -> Self {
        if weight_in_grams < 10 {
            // ã‚ã¾ã‚Šã‚ˆããªã„ä¾‹å¤–å‡¦ç†æ–¹æ³•ã§ã™ã€‚è‰¯ã„æ–¹æ³•ã¯åˆ¥ãªå›ã§ã€‚
            panic!("Can't ship a package with weight below 10 grams");
        }
        Self {
            sender_country,
            recipient_country,
            weight_in_grams,
        }
    }
}
```

---

# structs3.rs å•é¡Œ 2/5

```rust
impl Package {
    // TODO: æ­£ã—ã„è¿”ã‚Šå€¤å‹ã‚’è¿½åŠ ã—ã¦ãã ã•ã„
    fn is_international(&self) {
        // TODO: ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã‚ˆã†ã«ä¿®æ­£
    }

    // TODO: æ­£ã—ã„è¿”ã‚Šå€¤å‹ã‚’è¿½åŠ ã—ã¦ãã ã•ã„
    fn get_fees(&self, cents_per_gram: u32) {
        // TODO: ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸é‹è³ƒã‚’è¨ˆç®—ã—ã¦ãã ã•ã„
    }
}
```

---

# structs3.rs å•é¡Œ 3/5

`#[should_panic]` ã§ãƒ‘ãƒ‹ãƒƒã‚¯ã™ã‚‹å ´åˆãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã‚ˆã†ã«ã§ãã¾ã™

```rust
#[test]
#[should_panic]
fn fail_creating_weightless_package() {
    let sender_country = String::from("Spain");
    let recipient_country = String::from("Austria");

    Package::new(sender_country, recipient_country, 5);
}
```

---

# structs3.rs å•é¡Œ 4/5

å›½åã®åŒä¸€æ€§ã§å›½éš›ã‹ã©ã†ã‹ãŒæ±ºã¾ã‚Šãã†ã§ã™

<div class="mini-font-marker-7"></div>

```rust
#[test]
fn create_international_package() {
    let sender_country = String::from("Spain");
    let recipient_country = String::from("Russia");
    let package = Package::new(sender_country, recipient_country, 1200);

    assert!(package.is_international());
}

#[test]
fn create_local_package() {
    let sender_country = String::from("Canada");
    let recipient_country = sender_country.clone();
    let package = Package::new(sender_country, recipient_country, 1200);

    assert!(!package.is_international());
}
```

---

# structs3.rs å•é¡Œ 5/5

é‹è³ƒè¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ã‚‚ãƒ†ã‚¹ãƒˆã—ã¦ã„ã¾ã™

<div class="mini-font-marker-8"></div>

```rust
#[test]
fn calculate_transport_fees() {
    let sender_country = String::from("Spain");
    let recipient_country = String::from("Spain");

    let cents_per_gram = 3;

    let package = Package::new(sender_country, recipient_country, 1500);

    assert_eq!(package.get_fees(cents_per_gram), 4500);
    assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
}
```

---

# TIPS: UFCS 1/2

Nimã¨ã„ã†è¨€èªã§ã¯ã€
`func(arg1, arg2)` ã¨ã„ã†å‘¼ã³å‡ºã—ã‚’ `arg1.func(arg2)` ã¨æ›¸ã‘ã¾ã™ï¼

```nim
proc plus(x, y: int): int =
  return x + y
proc multi(x, y: int): int =
  return x * y

echo multi(plus(1, 2), 3)
echo 1.plus(2).multi(3)
```

ã“ã®ç³–è¡£æ§‹æ–‡ã‚’ **UFCS (Uniform Function Call Syntax)** ã¨å‘¼ã³ã¾ã™

---

# TIPS: UFCS 2/2

Rust ã®ãƒ¡ã‚½ãƒƒãƒ‰ãƒ¬ã‚·ãƒ¼ãƒ `self` ã‚‚UFCSã‚‚ã©ããªèº«åˆ†ã§ã€
`arg1.method(arg2)` ã¯ `Strct::method(arg1, arg2)` ã¿ãŸã„ã«æ›¸ã‘ã¾ã™ï¼

```rust
fn main() {
    let s1 = "aaa".to_uppercase();
    // â†‘ ã¯å®Ÿéš›çš„ã«ã¯ â†“ ã¨åŒã˜
    let s2 = str::to_uppercase("aaa");
    
    println!("{s1}");
    assert_eq!(s1, s2);
}
```

---

# structs1.rs è§£ç­”

<div class="mini-font-marker-8"></div>

```rust
// å®šç¾©éƒ¨åˆ†
struct ColorRegularStruct {
    red: u8,
    green: u8,
    blue: u8,
}

struct ColorTupleStruct(u8, u8, u8);

// å®Ÿä½“åŒ–éƒ¨åˆ†
let green = ColorRegularStruct {
    red: 0,
    green: 255,
    blue: 0,
};
let green = ColorTupleStruct(0, 255, 0);
let unit_struct = UnitStruct;
```

---

# structs2.rs è§£ç­”

`name` ã¨ `count` ã®ã¿ç•°ãªã‚‹ã®ã§æ›´æ–°ã—ã¦ã„ã¾ã™

```rust
let your_order = Order {
    name: "Hacker in Rust".to_string(),
    count: 1,
    ..create_order_template()
};
```

å…ƒã¨ãªã‚‹æ§‹é€ ä½“ã¯æœ€å¾Œã« `..ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹` ã¨ã„ã†å½¢ã§åŠ ãˆã¦ã„ã¾ã™

---

# structs3.rs è§£ç­”

`self` ãƒ¬ã‚·ãƒ¼ãƒã‚’çµŒç”±ã—ã¦å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™

```rust
fn is_international(&self) -> bool {
    self.sender_country != self.recipient_country
}

fn get_fees(&self, cents_per_gram: u32) -> u32 {
    self.weight_in_grams * cents_per_gram
}
```

---

# æœ¬æ—¥ã®RustãƒŸãƒ‹ã‚¯ã‚¤ã‚º! (å†æ²)

<div class="mini-font-marker-8"></div>

```rust
macro_rules! check_impl_copy {
    ($v:expr) => {
        let v1 = $v;
        let v2 = v1;
        println!("{v1:?}, {v2:?}");
    };
}

fn main() {
    /* 1. */ check_impl_copy!(10);
    /* 2. */ check_impl_copy!('\u{3042}');
    /* 3. */ check_impl_copy!(vec![1, 2, 3]);
    /* 4. */ check_impl_copy!([1, 2, 3]);
}
```

 1. ~ 4. ã®ã†ã¡ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã¨ãªã‚‹è¡Œã¯ã©ã‚Œã§ã—ã‚‡ã†ï¼Ÿ

---

# æœ¬æ—¥ã®RustãƒŸãƒ‹ã‚¯ã‚¤ã‚º! ç­”ãˆ

ç­”ãˆã¯ **3. `vec![1, 2, 3]`** ã§ã™!

- 1. æ•´æ•°å‹ã¯ `Copy` ãƒˆãƒ¬ã‚¤ãƒˆãŒã¤ã„ã¦ã„ã¾ã™
- 2. ã“ã‚Œã¯ `char` å‹ã§ã€ `Copy` ã‚ã‚Š
- 3. **`Vec` ã¯ `Copy` ã‚’å®Ÿè£…ã—ã¾ã›ã‚“**
- 4. é…åˆ—ã¯è¦ç´ ã®å‹ãŒ `Copy` ã‚’å®Ÿè£…ã™ã‚‹æ™‚ `Copy` ã§ã™